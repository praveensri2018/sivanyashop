<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Local Folder Summarizer — Tree View</title>
<style>
  :root{--bg:#f6f8fa;--card:#fff;--muted:#666;--accent:#2b7cff}
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#111;margin:0;padding:18px}
  .wrap{max-width:1100px;margin:0 auto}
  header{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:20px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input[type="text"]{padding:8px;border-radius:6px;border:1px solid #ddd}
  button{padding:8px 10px;border-radius:6px;border:1px solid #cfcfcf;background:#fff;cursor:pointer}
  button.primary{background:var(--accent);color:#fff;border-color:transparent}
  .panel{background:var(--card);border:1px solid #e6e6e6;padding:12px;border-radius:8px;margin-top:12px;box-shadow:0 1px 2px rgba(0,0,0,0.03)}
  .left{width:46%;min-width:320px}
  .right{flex:1;margin-left:16px}
  .tree{max-height:520px;overflow:auto;padding:6px;border-radius:6px;border:1px solid #eee;background:#fafafa}
  ul.tree-root, ul.folder{list-style:none;margin:0;padding-left:18px}
  .node{display:flex;align-items:center;gap:8px;padding:4px;border-radius:4px}
  .node:hover{background:#fff}
  .folder-toggle{width:16px;height:16px;display:inline-flex;align-items:center;justify-content:center;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .file-meta{font-size:12px;color:#666}
  .summary-area{white-space:pre-wrap;font-family:ui-monospace,monospace;background:#fff;padding:8px;border-radius:6px;border:1px solid #f0f0f0;max-height:420px;overflow:auto}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  .row{display:flex;gap:8px;align-items:center}
  textarea.prompt{width:100%;height:140px;padding:10px;border-radius:6px;border:1px solid #ddd;resize:vertical}
  .small{font-size:13px;color:var(--muted)}
  .spinner{width:14px;height:14px;border:2px solid #ddd;border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;display:inline-block}
  @keyframes spin{to{transform:rotate(360deg)}}
  .actions{margin-left:auto;display:flex;gap:6px}
  .path-small{font-size:12px;color:#666}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Local Folder Summarizer — Tree View</h1>
      <div class="controls">
        <button id="pickDirBtn">Pick Folder (showDirectoryPicker)</button>
        <button id="fallbackBtn">Fallback: Choose Folder</button>
        <input id="fileInput" type="file" webkitdirectory directory multiple style="display:none" />
        <button id="scanBtn" class="primary">Scan</button>
      </div>
    </header>

    <div class="panel" style="display:flex;gap:12px;align-items:flex-start">
      <div class="left">
        <div class="toolbar">
          <button id="expandAllBtn">Expand All</button>
          <button id="collapseAllBtn">Collapse All</button>
          <button id="selectAllBtn">Select All</button>
          <button id="clearAllBtn">Clear All</button>
          <div class="actions">
            <button id="previewCheckedBtn">Preview Checked</button>
          </div>
        </div>

        <div class="small">Folder tree (uncheck items to skip them)</div>
        <div id="tree" class="tree"><div class="muted">No folder selected.</div></div>
      </div>

      <div class="right">
        <div class="row" style="align-items:flex-start">
          <div style="flex:1">
            <div class="small">Summaries</div>
            <div id="summaries" class="summary-area">(no summaries yet)</div>
            <div style="margin-top:8px;display:flex;gap:8px">
              <button id="summBtn" class="primary">Summarize Selected</button>
              <button id="copyAllBtn">Copy All Summaries</button>
              <button id="genPromptBtn">Generate Prompt</button>
            </div>
          </div>
        </div>

        <div style="margin-top:12px">
          <div class="small">Generated Prompt (editable)</div>
          <textarea id="promptArea" class="prompt" placeholder="Generated prompt will appear here..."></textarea>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <button id="copyPromptBtn">Copy Prompt</button>
            <button id="clearPromptBtn">Clear</button>
            <div style="margin-left:auto;" class="muted">Tip: paste into AI tool (OpenAI/HF).</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Tanglish: Full tree + checkbox UI. Works with showDirectoryPicker or webkitdirectory fallback.
   - Folder checkbox toggles children.
   - Unchecked = skip file.
   - Buttons: expand/collapse/select/clear/summarize
*/

const allowedExt = ['.js','.ts','.html','.css','.scss'];

const pickDirBtn = document.getElementById('pickDirBtn');
const fallbackBtn = document.getElementById('fallbackBtn');
const fileInput = document.getElementById('fileInput');
const scanBtn = document.getElementById('scanBtn');

const treeEl = document.getElementById('tree');
const sumEl = document.getElementById('summaries');

const expandAllBtn = document.getElementById('expandAllBtn');
const collapseAllBtn = document.getElementById('collapseAllBtn');
const selectAllBtn = document.getElementById('selectAllBtn');
const clearAllBtn = document.getElementById('clearAllBtn');
const previewCheckedBtn = document.getElementById('previewCheckedBtn');

const summBtn = document.getElementById('summBtn');
const copyAllBtn = document.getElementById('copyAllBtn');
const genPromptBtn = document.getElementById('genPromptBtn');
const promptArea = document.getElementById('promptArea');
const copyPromptBtn = document.getElementById('copyPromptBtn');
const clearPromptBtn = document.getElementById('clearPromptBtn');

let fileItems = []; // array of {path, name, handle or file}
let treeData = {};  // nested object representing tree

// UTIL
function extOf(name){ const i = name.lastIndexOf('.'); return i>=0?name.slice(i).toLowerCase():''; }
function escapeHtml(s){ return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// Build treeData from fileItems paths
function buildTree(items){
  const root = {};
  for (const it of items){
    const parts = it.path.split('/');
    let node = root;
    for (let i=0;i<parts.length;i++){
      const p = parts[i];
      if (!node.children) node.children = {};
      if (!node.children[p]) node.children[p] = { name: p, children: null, files: null };
      if (i === parts.length-1){
        // file node
        if (!node.children[p].files) node.children[p].files = [];
        // but to avoid treating file as folder, we will mark file at parent
      }
      node = node.children[p];
    }
  }
  // Simpler: we will instead construct a directory tree where files are entries under parent directories
  const tree = {};
  for (const it of items){
    const parts = it.path.split('/');
    let node = tree;
    for (let i=0;i<parts.length-1;i++){
      const d = parts[i];
      node[d] = node[d] || { __files: {}, __dirs: {} };
      node = node[d].__dirs;
    }
    // parent dir in node container where last dir lives
    const parentDirName = parts.length>1 ? parts[parts.length-2] : '/';
    // Instead of using parentDirName, we place file under current node object
    const fileName = parts[parts.length-1];
    node.__files = node.__files || {};
    node.__files[fileName] = node.__files[fileName] || [];
    // store handle reference in fileItemsMap? Simpler: keep global map path->item
    // We'll store file entry under special map
  }
  // The above got messy; easier approach: convert paths to nested map straightforwardly below.
  const out = {};
  for (const it of items){
    const parts = it.path.split('/');
    let cur = out;
    for (let i=0;i<parts.length;i++){
      const p = parts[i];
      if (i === parts.length-1){
        // file
        cur.__files = cur.__files || {};
        cur.__files[p] = it;
      } else {
        cur[p] = cur[p] || {};
        cur = cur[p];
      }
    }
  }
  return out;
}

// Render tree recursively
function renderTree(node, parentPath=''){
  const ul = document.createElement('ul');
  ul.className = parentPath ? 'folder' : 'tree-root';
  for (const key of Object.keys(node).sort((a,b)=>a.localeCompare(b))){
    if (key === '__files') continue;
    const li = document.createElement('li');
    const fullPath = parentPath ? parentPath + '/' + key : key;
    // folder node
    const folderDiv = document.createElement('div');
    folderDiv.className = 'node';
    const toggle = document.createElement('span');
    toggle.className = 'folder-toggle';
    toggle.textContent = '▶';
    toggle.style.userSelect = 'none';
    const chk = document.createElement('input');
    chk.type = 'checkbox';
    chk.dataset.path = fullPath;
    chk.checked = true;
    const nameSpan = document.createElement('span');
    nameSpan.textContent = key + '/';
    nameSpan.style.fontWeight = '600';
    nameSpan.className = 'path-small';
    const actions = document.createElement('div'); actions.className = 'actions';
    const countSpan = document.createElement('span'); countSpan.className='muted';
    // compute counts for folder
    const counts = countFilesInNode(node[key]);
    countSpan.textContent = ` ${counts} files`;
    folderDiv.appendChild(toggle);
    folderDiv.appendChild(chk);
    folderDiv.appendChild(nameSpan);
    folderDiv.appendChild(countSpan);
    folderDiv.appendChild(actions);

    li.appendChild(folderDiv);

    // children container
    const childContainer = document.createElement('div');
    childContainer.style.display = 'none';
    childContainer.style.paddingLeft = '12px';

    // folder checkbox toggle children
    chk.addEventListener('change', ()=> {
      const checked = chk.checked;
      // toggle all descendant checkboxes
      const inputs = childContainer.querySelectorAll('input[type=checkbox]');
      inputs.forEach(i=> i.checked = checked);
    });

    // toggle arrow
    toggle.addEventListener('click', () => {
      if (childContainer.style.display === 'none'){
        childContainer.style.display = '';
        toggle.textContent = '▼';
      } else {
        childContainer.style.display = 'none';
        toggle.textContent = '▶';
      }
    });

    // render child folders recursively
    const childNode = node[key];
    // render subfolders
    const subUl = renderTree(childNode, fullPath);
    // append subfiles under node
    if (childNode.__files){
      const filesDiv = document.createElement('div');
      filesDiv.style.display = 'flex';
      filesDiv.style.flexDirection = 'column';
      filesDiv.style.gap = '4px';
      for (const fname of Object.keys(childNode.__files).sort((a,b)=>a.localeCompare(b))){
        const fileItem = childNode.__files[fname]; // the item object with path and handle/file
        const fileDiv = document.createElement('div');
        fileDiv.className = 'node';
        const fileChk = document.createElement('input');
        fileChk.type = 'checkbox';
        fileChk.dataset.path = (fullPath ? fullPath + '/' + fname : fname);
        fileChk.checked = true;
        const fnSpan = document.createElement('span');
        fnSpan.textContent = fname;
        fnSpan.className = 'path-small';
        const viewBtn = document.createElement('button');
        viewBtn.textContent = 'View';
        viewBtn.style.marginLeft = 'auto';
        viewBtn.addEventListener('click', async ()=>{
          // preview single file
          sumEl.textContent = 'Loading preview...';
          const r = await summarizeSingleFile(fileItem);
          sumEl.innerHTML = `<div style="font-weight:600">${escapeHtml(r.path)}</div><pre style="white-space:pre-wrap">${escapeHtml(r.summary)}</pre>`;
        });
        fileDiv.appendChild(fileChk);
        fileDiv.appendChild(fnSpan);
        fileDiv.appendChild(viewBtn);
        filesDiv.appendChild(fileDiv);
      }
      childContainer.appendChild(filesDiv);
    }
    childContainer.appendChild(subUl);

    li.appendChild(childContainer);
    ul.appendChild(li);
  }

  // if there are __files at this level root (only when parentPath empty)
  if (node.__files && Object.keys(node.__files).length){
    for (const fname of Object.keys(node.__files).sort((a,b)=>a.localeCompare(b))){
      const it = node.__files[fname];
      const li = document.createElement('li');
      const fileDiv = document.createElement('div');
      fileDiv.className = 'node';
      const chk = document.createElement('input'); chk.type='checkbox'; chk.dataset.path = fname; chk.checked = true;
      const span = document.createElement('span'); span.textContent = fname; span.className='path-small';
      const viewBtn = document.createElement('button'); viewBtn.textContent='View'; viewBtn.style.marginLeft='auto';
      viewBtn.addEventListener('click', async ()=>{
        sumEl.textContent = 'Loading preview...';
        const r = await summarizeSingleFile(it);
        sumEl.innerHTML = `<div style="font-weight:600">${escapeHtml(r.path)}</div><pre style="white-space:pre-wrap">${escapeHtml(r.summary)}</pre>`;
      });
      fileDiv.appendChild(chk); fileDiv.appendChild(span); fileDiv.appendChild(viewBtn);
      li.appendChild(fileDiv);
      ul.appendChild(li);
    }
  }

  return ul;
}

// count files helper
function countFilesInNode(node){
  let c = 0;
  if (!node) return 0;
  if (node.__files) c += Object.keys(node.__files).length;
  for (const k of Object.keys(node)){
    if (k === '__files') continue;
    c += countFilesInNode(node[k]);
  }
  return c;
}

// summarize single file (same rule-based summarizer)
async function summarizeSingleFile(item){
  try{
    let text = '';
    if (item.handle && typeof item.handle.getFile === 'function'){
      const f = await item.handle.getFile();
      text = await f.text();
    } else if (item.file){
      text = await item.file.text();
    } else {
      return { path: item.path, summary: 'Cannot read file' };
    }
    text = text.replace(/\/\*[\s\S]{400,}?\*\//g, '/*...truncated...*/');
    const lines = text.split(/\r?\n/).map(l=>l.replace(/\t/g,'    '));
    const firstNonEmpty = lines.findIndex(l=>l.trim().length>0);
    const head = lines.slice(Math.max(0,firstNonEmpty), Math.min(lines.length, (firstNonEmpty===-1?0:firstNonEmpty)+30)).join('\n').trim();
    const tail = lines.slice(Math.max(0, lines.length-5)).join('\n').trim();
    const snippet = text.slice(0,8000);
    const ids = new Set();
    const reExport = /(?:export\s+(?:const|let|var|function|class)\s+([A-Za-z0-9_$]+))/g;
    let m;
    while((m=reExport.exec(snippet))!=null) ids.add(m[1]);
    const m2 = snippet.match(/module\.exports\s*=\s*([A-Za-z0-9_$]+)/);
    if (m2) ids.add(m2[1]);
    if (/@Component\b/.test(snippet) || /@Directive\b/.test(snippet)) ids.add('AngularComponent/Directive?');

    const parts = [];
    parts.push(`File: ${item.path}`);
    if (ids.size) parts.push(`Key identifiers: ${Array.from(ids).slice(0,8).join(', ')}`);
    parts.push('--- Head (first lines) ---');
    parts.push(head || '(empty)');
    parts.push('--- Tail (last lines) ---');
    parts.push(tail || '(empty)');
    const out = parts.join('\n').slice(0,3000);
    return { path: item.path, summary: out + (out.length>=3000?'\n...truncated...':'') };
  }catch(e){
    return { path: item.path, summary: 'ERROR reading file: ' + e.message };
  }
}

// collect checked file items from tree
function getCheckedFilesFromTree(){
  const checked = [];
  const checks = treeEl.querySelectorAll('input[type=checkbox]');
  checks.forEach(chk=>{
    // file checkboxes were created with dataset.path of full file path and have corresponding fileItems map
    const path = chk.dataset.path;
    if (!path) return;
    // Determine if this path denotes a file - we check our map
    const it = fileItemsMap[path];
    if (it && chk.checked) checked.push(it);
  });
  return checked;
}

// flatten fileItems list and build map path->item
let fileItemsMap = {};

// showDirectoryPicker flow
pickDirBtn.addEventListener('click', async ()=>{
  if (!window.showDirectoryPicker){
    alert('showDirectoryPicker not supported — use fallback');
    return;
  }
  try{
    const dir = await window.showDirectoryPicker();
    const items = [];
    async function walk(dh, prefix=''){
      for await (const [name, handle] of dh.entries()){
        if (handle.kind === 'file'){
          const ext = extOf(name);
          if (allowedExt.includes(ext)){
            items.push({ path: prefix + name, name, handle });
          }
        } else if (handle.kind === 'directory'){
          await walk(handle, prefix + name + '/');
        }
      }
    }
    await walk(dir);
    fileItems = items.sort((a,b)=>a.path.localeCompare(b.path));
    fileItemsMap = {}; fileItems.forEach(it=> fileItemsMap[it.path] = it);
    treeData = buildTree(fileItems);
    treeEl.innerHTML = '';
    treeEl.appendChild(renderTree(treeData));
    sumEl.innerText = `Found ${fileItems.length} files. Uncheck files/folders to skip.`;
  }catch(e){
    if (e.name === 'AbortError') sumEl.innerText = 'Pick cancelled';
    else sumEl.innerText = 'Error: '+ e.message;
  }
});

// fallback - webkitdirectory
fallbackBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', (ev)=>{
  const files = Array.from(ev.target.files || []);
  const items = [];
  for (const f of files){
    const ext = extOf(f.name);
    if (allowedExt.includes(ext)){
      const rel = f.webkitRelativePath || f.name;
      items.push({ path: rel, name: f.name, file: f });
    }
  }
  fileItems = items.sort((a,b)=>a.path.localeCompare(b.path));
  fileItemsMap = {}; fileItems.forEach(it=> fileItemsMap[it.path] = it);
  treeData = buildTree(fileItems);
  treeEl.innerHTML = '';
  treeEl.appendChild(renderTree(treeData));
  sumEl.innerText = `Found ${fileItems.length} files. Uncheck files/folders to skip.`;
});

// helper actions
expandAllBtn.addEventListener('click', ()=> {
  treeEl.querySelectorAll('div.folder-toggle').forEach(t=>{ t.textContent='▼'; const c=t.parentElement.nextSibling; if(c) c.style.display=''; });
  // old structure uses .folder-toggle class name on span; ensure selection works across browsers
  treeEl.querySelectorAll('.folder-toggle').forEach(t=>{ t.textContent='▼'; const c = t.parentElement.nextSibling; if (c) c.style.display = ''; });
});
collapseAllBtn.addEventListener('click', ()=> {
  treeEl.querySelectorAll('.folder-toggle').forEach(t=>{ t.textContent='▶'; const c = t.parentElement.nextSibling; if(c) c.style.display='none'; });
});
selectAllBtn.addEventListener('click', ()=> {
  treeEl.querySelectorAll('input[type=checkbox]').forEach(chk=> chk.checked = true);
});
clearAllBtn.addEventListener('click', ()=> {
  treeEl.querySelectorAll('input[type=checkbox]').forEach(chk=> chk.checked = false);
});

// preview checked (summarize only first checked file quickly)
previewCheckedBtn.addEventListener('click', async ()=>{
  const allChecked = getCheckedFilesFromTree();
  if (!allChecked.length){ alert('No files selected'); return; }
  sumEl.innerText = 'Loading preview...';
  const r = await summarizeSingleFile(allChecked[0]);
  sumEl.innerHTML = `<div style="font-weight:600">${escapeHtml(r.path)}</div><pre style="white-space:pre-wrap">${escapeHtml(r.summary)}</pre>`;
});

// summarize selected
summBtn.addEventListener('click', async ()=>{
  // collect checked files by inspecting checkboxes and map
  const checks = Array.from(treeEl.querySelectorAll('input[type=checkbox]'));
  const selectedPaths = [];
  checks.forEach(chk=>{
    const p = chk.dataset.path;
    if (!p) return;
    // we treat a path as file if it exists in fileItemsMap
    if (fileItemsMap[p] && chk.checked) selectedPaths.push(p);
  });
  if (!selectedPaths.length){ alert('No files selected'); return; }
  sumEl.innerText = 'Summarizing selected files...';
  const results = [];
  for (const p of selectedPaths){
    const it = fileItemsMap[p];
    const r = await summarizeSingleFile(it);
    results.push(r);
  }
  // render combined
  sumEl.innerHTML = results.map(r=> `<div style="font-weight:600">${escapeHtml(r.path)}</div><pre style="white-space:pre-wrap">${escapeHtml(r.summary)}</pre>`).join('<hr/>');
  // store current summaries for prompt/copy
  window.currentSummaries = results;
});

// copy all summaries
copyAllBtn.addEventListener('click', ()=>{
  const s = window.currentSummaries || [];
  if (!s.length){ alert('No summaries to copy'); return; }
  const txt = s.map(r=> `--- ${r.path} ---\n${r.summary}`).join('\n\n');
  navigator.clipboard.writeText(txt).then(()=> alert('Summaries copied'));
});

// generate prompt
genPromptBtn.addEventListener('click', ()=>{
  const s = window.currentSummaries || [];
  if (!s.length){ alert('No summaries — summarize first'); return; }
  const combined = s.map(r=> `File: ${r.path}\nSummary:\n${r.summary}`).join('\n\n');
  const prompt = [
    "You are an experienced software engineer. Below are short summaries of important project files.",
    "Please provide:",
    "1) A concise list of recommended code changes / refactors (bullet points).",
    "2) A short implementation plan (3-6 steps).",
    "3) Example code snippets if helpful.",
    "",
    "Summaries:",
    combined,
    "",
    "Answer concisely."
  ].join('\n');
  promptArea.value = prompt;
  promptArea.scrollIntoView({behavior:'smooth'});
});

// copy prompt and clear
copyPromptBtn.addEventListener('click', ()=> {
  const t = promptArea.value.trim();
  if (!t) { alert('Prompt empty'); return; }
  navigator.clipboard.writeText(t).then(()=> alert('Prompt copied'));
});
clearPromptBtn.addEventListener('click', ()=> promptArea.value = '');

// small scan button (rebuild tree if fileItems already loaded)
scanBtn.addEventListener('click', ()=> {
  if (!fileItems || !fileItems.length){ alert('No folder loaded — pick or fallback first'); return; }
  treeData = buildTree(fileItems);
  treeEl.innerHTML = '';
  treeEl.appendChild(renderTree(treeData));
  sumEl.innerText = `Found ${fileItems.length} files. Uncheck files/folders to skip.`;
});

// Helper: buildTree improved (simple)
function buildTree(fileList){
  const root = {};
  for (const it of fileList){
    const parts = it.path.split('/');
    let cur = root;
    for (let i=0;i<parts.length;i++){
      const p = parts[i];
      if (i === parts.length-1){
        // file
        cur.__files = cur.__files || {};
        cur.__files[p] = it;
      } else {
        cur[p] = cur[p] || {};
        cur = cur[p];
      }
    }
  }
  return root;
}

// initial state
window.currentSummaries = [];
</script>
</body>
</html>
